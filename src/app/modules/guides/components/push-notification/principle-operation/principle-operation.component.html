<mat-card class="pwa-page" >
	<h4 id="howPushWorks" pwa-query-selector>Технологическая последовательность запуска уведомления (Push API).</h4>
	<p>Прежде чем начать изучение <span class="dark-blue" >Push API</span>, проследим цепочку последовательных действий (технологический процесс), необходимых для реализации технологии Push с начала до конца. Затем рассмотрим отдельно звенья этой технологической цепочки, где разберем как это работает, и почему это так важно. </p>
	<ul>
		Существуют три основных шага реализации:
		<li>Добавление клиенской логики подписки пользователя на получение уведомлений. Это клиентский код и блок пользовательского интерфейса, который отображается пользователю с запросом на разрешение подписки.</li>
		<li>Серверный вызов, который запускает формирование сообщения для устройства пользователя.</li>
		<li>Сервисный рабочий, который будет получать и обрабатывать входящее сообщение, по событию <span class="dark-blue">push</span> на устройстве пользователя, формируя код отображения уведомления.</li>
	</ul>
	<h5 id="clientSide" pwa-query-selector>Клиентская сторона.</h5>
	<p>Первый шаг - подписать пользователя на получение входящих уведомлений. Эта подписка требует двух условий :</p>
	<ul>
		<li>Получить разрешение пользователя на направление ему уведомлений.</li>
		<li>Получить объект подписки <span class="dark-blue">PushSubscription</span> браузера.</li>
	</ul>
	<div>Объект подписки содержит информацию, необходимую для отправки с сервера сообщения пользователю, и может рассматриваться как идентификатор для пользовательского устройства. Все это выполняется в Javascript, используя <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API">PUSH API</a>.<br>
	Как только разрешение получено, необходимо сгенерировать серверный ключ приложения, называемый <span class="dark-blue">VAPID</span> ключем, являющийся уникальным для сервера приложения. Он позволяет Push сервису знать, на какое приложение он подписывает пользователя и гарантирует, что отправителем сообщений этоиу пользователю будет являеться тот-же сервер приложения. <br>
	Как только подписка оформлена и сгенерирован ключ приложения, объект подписки <span class="dark-blue">PushSubscription</span> должен быть направлен на сервер приложения, где сохраняется в базе данных приложения и используется для отправки сообщений пользователю.
		<div class="imgContainer">
			<img src="assets/icons/principle-operation/browser-to-server.svg">
		</div>
	</div>
	<h4 id="sendMessage" pwa-query-selector>Отправка сообщений.</h4>
	<p>Когда нужно отправить сообщение пользоватлю, необходимо выполнить API вызов на сервис уведомлений. Этот вызов включает нагрузку(текст сообщения или иные данные), данные отправителя, метаданные формирования сообщения. Этот вызов осуществляется с сервера приложения. В связи с этим возникают некоторые вопросы:</p>
	<ul>
		<li>Кто или что такое сервис уведомлений?</li>
		<li>Какой формат API вызова : json, xml, или иное?</li>
		<li>Какова функциональность API?</li>
	</ul>
	<h5 id="whatPushService" pwa-query-selector>Кто или что такое сервис уведомлений?</h5>
	<p>Сервис уведомлений - постоянно работающий сетевой ресурс уведомлений, получающий сетевые запросы на отправку сообщений, проверяющий их и доставляющий их в соответствующие браузеры по определенным идентификаторам. Если браузер не запущен, сообщение становиться в очередь до момента выхода браузера в сеть.<br>
	Каждый браузер использует собственный сервис уведомлений и разработчик приложения не может на это повлиять, но это не является критичным, поскольку все сервисы уведомлений реализуют одни и теже API вызовы, и разработчику нужно лишь только правильно сформулировать вызов.<br>
	Для отправки запроса, необходимо получить адрес на который следует обратиться, он находиться в свойстве <span class="dark-blue">endpoint</span> объекта <span class="dark-blue">PushNotification</span>, который получается в ответ на вызов подключения подписки. Этот адрес уникален для каждого устройства. Ниже, пример объекта подписки, который содержит свойства, необходимые в процессе передачи сообщений:  </p>
	<pwa-example-code [context]="{header : 'Объект подписки', ext : '.json'}"><pre><span class="green">&#123;
"endpoint": "https://random-push-service.com/some-kind-of-unique-id-1234/v2/",
"keys": &#123;
   "p256dh" : "BNcRdreALRFXTkOOUHK1EtK2wtaz5Ry4YfYCA_0QTpQtUbVlUls0VJXg7A8u-Ts1XbjhazAkj7I99e8QcYP7DkM=",
   "auth"   : "tBHItJI5svbpez7KI4CCXg=="
   &#125;
&#125;</span></pre></pwa-example-code>
	<p>Какой бы сервис уведомдений не выбрал браузер, этот сервис использует один и тот же API. Таким интерфейсом является <a target="_blank" href="https://tools.ietf.org/html/draft-ietf-webpush-protocol-12">Web Push Protocol</a> - IETF стандарт, определяющий правила и порядок вызова сервиса уведомлений. Этот вызов требует установку определенных заголовков и наличия данных для передачи в потоке. <br>
	Этот интерфейс предоставляет способ отправки сообщения пользователю с данными, или без, содержит инструкции того, как сервис должен обработать сообщение.<br>
	Данные направляемые пользователю должны кодироваться, для предотвращения перехвата сообщений на стороне сервиса уведомлений, который является посторонним посредником. При отправке сообщения с сервера приложения именно сервис уведомлений будет получать этот вызов и ставить сообщение в очередь на отправку. Сообщение остается в очереди, пока устройство пользователя не войдет в сеть, что запустит процесс передачи сообщения на активное устройство. Инструкции, которые можно передать сервису уведомлений могут определять особенности процесса передачи, перечисленные ниже:</p>
	<ul>
		<li>Время жизни передаваемого сообщения. Определяет продолжительность нахождения сообщения в очереди, после которой сообщение удаляется из очереди не доставленным.</li>
		<li>Срочность сообщения. Полезно в случае экономии заряда батареи устройства, доставляя первоочередно сообщения с высоким приоритетом.</li>
		<li>Группировка сообщений, установкой им тематических заголовков, по которым можно замещать ожидающие доставки сообщения новыми версиями. </li>
	</ul>
	<div class="imgContainer">
		<img src="/assets/icons/principle-operation/server-to-push-service.svg">
	</div>
	<h4 id="sendDeviceMessage" pwa-query-selector>Отправка сообщения на устройство пользователя.</h4>
	<p>Когда сервер приложения отправил сообщение, оно получается сервисом уведомления и сохраняется там до одного из следующих событий:</p>
	<ul>
		<li>Устройство пользователя вошло в сеть и сервис сразу отправляет сообщение.</li>
		<li>Срок хранения сообщения истек и сообщение удаляется из очереди ожидания не доставленным.</li>
	</ul>
	<p>Когда сообщение доставляется на устройство, его получает браузер, декодирует данные и запускает событие <span class="dark-blue">push</span> на которое подписан сервисный рабочий обработки входящий уведомлений. Сервисный рабочий - javascript файл, чей код исполняется браузером без необходимости запуска какой нибудь страницы или вообще без явного браузерного запуска (в фоне). Сервисный рабочий имеет интерфейс, который не доступен на веб страницах (т.е. доступен только внутри скрипта сервисного рабочего). Этому скрипту доступно событие <span class="dark-blue">push</span>, по котрому выполняются все фоновые задачи : вызовы интерфейса аналитики, кэширование страниц, отображение уведомления пользователю и др. Ниже, графика событийного потока получения устройством сообщения:  </p>
	<div class="imgContainer">
		<img src="/assets/icons/principle-operation/push-service-to-sw-event.svg">
	</div>
</mat-card>